% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cva.penAFTFormula.R
\name{penAFT.cva}
\alias{penAFT.cva}
\alias{penAFT.cva.default}
\alias{predict.penAFT.cva}
\alias{minlossplot}
\alias{minlossplot.penAFT.cva}
\title{Do elastic net cross-validation for alpha and lambda simultaneously (based on glmnetUtils package)}
\usage{
penAFT.cva(x, ...)

\method{penAFT.cva}{default}(
  x,
  logY,
  delta,
  alpha = seq(0, 1, len = 11)^3,
  nfolds = 10,
  seed = NULL,
  ...,
  outerParallel = NULL,
  checkInnerParallel = TRUE
)

\method{predict}{penAFT.cva}(
  object,
  newx,
  alpha,
  which = match(TRUE, abs(object$alpha - alpha) < 1e-08),
  lambda = NULL,
  ...
)

minlossplot(x, ...)

\method{minlossplot}{penAFT.cva}(x, ..., cv.type = c("min", "1se"))
}
\arguments{
\item{x}{A matrix of predictor variables; or for the plotting methods, an object returned by \code{penAFT.cva}.}

\item{...}{Further arguments to be passed to lower-level functions. In the case of \code{penAFT.cva}, these arguments are passed to \code{penAFT.cv}; for \code{predict} and \code{coef}, they are passed to \code{predict.cv.glmnet}; and for \code{plot} and \code{minlossplot}, to \code{plot}.}

\item{logY}{A response vector ( with n-elements) of log-survival or log-censoring times.}

\item{delta}{A binary vector indicating whether the jth element of logY is an observed log-survival time (d_j = 1) or a log-censoring time (d_j = 0) for j=1,..., n.}

\item{alpha}{desired value of alpha parameter (scalar)}

\item{nfolds}{The number of cross-validation folds to use. Defaults to 10.}

\item{seed}{Seed value. Defualts to NULL.}

\item{outerParallel}{Method of parallelising the outer loop over alpha. See 'Details' below. If \code{NULL}, the loop is run sequentially.}

\item{checkInnerParallel}{If the outer loop is run in parallel, check that the inner loop over lambda will not be in contention for cores.}

\item{object}{For the \code{predict} and \code{coef} methods, an object returned by \code{penAFT.cva}.}

\item{newx}{For the \code{predict} method, a matrix of predictor variables.}

\item{which}{An alternative way of specifying alpha; the index number of the desired value within the alpha vector. If both \code{which} and \code{alpha} are supplied, the former takes precedence.}

\item{cv.type}{For \code{minlossplot}, which cross-validated loss value to plot for each value of alpha. This can be either \code{"min"} which is the minimum loss, or \code{"1se"} which is the highest loss within 1 standard error of the minimum. The default is \code{"1se"}.}
}
\description{
Do elastic net cross-validation for alpha and lambda simultaneously (based on glmnetUtils package)
}
\details{
The \code{penAFT.cva} function does simultaneous cross-validation for both the alpha and lambda parameters in an elastic net model. The procedure is as outlined in the documentation for \link[glmnet:cv.glmnet]{glmnet::cv.glmnet}: it creates a vector \code{foldid} allocating the observations into folds, and then calls \code{penAFT.cv} in a loop over different values of alpha, but the same values of \code{foldid} each time.

Optionally this loop over alpha can be parallelised; currently, \code{penAFT.cva} knows about two methods of doing so:
\itemize{
\item Via \link{parLapply} in the parallel package. To use this, set \code{outerParallel} to a valid cluster object created by \link{makeCluster}.
\item Via \code{rxExec} as supplied by Microsoft R Server's RevoScaleR package. To use this, set \code{outerParallel} to a valid compute context created by \code{RxComputeContext}, or a character string specifying such a context.
}

If the outer loop is run in parallel, \code{penAFT.cva} can check if the inner loop (over lambda) is also set to run in parallel, and disable this if it would lead to contention for cores. This is done if it is likely that the parallelisation is local on a multicore machine, ie if \code{outerParallel} is a \code{SOCKcluster} object running on \code{"localhost"}, or if the RevoScaleR compute context is local parallel.

The \code{predict} method computes predictions for a specific alpha value given a \code{penAFT.cva} object. It looks up the supplied alpha (possibly supplied indirectly via the \code{which} argument) in the object's stored \code{alpha} vector, and calls \code{penAFT::penAFT.predict} on the corresponding \code{penAFT.cv} fit. All the arguments to that function are (or should be) supported.

The \code{minlossplot} function gives the best (lowest) C-V loss for each value of alpha.
}
\examples{
\dontrun{
dtc <- proteins21
X  <- as.matrix(dtc[, 3:26])
logY  <- log(dtc[, "time"]) 
delta <- dtc[, "status"]   # status=0 indicates censored observation 
fit.en.cva <- penAFT.cva(x=X, logY = logY, delta = delta,
              alpha = seq(0, 1, len = 11)^3,
              nlambda = 50, lambda.ratio.min = 0.1, lambda = NULL,
              penalty = "EN", nfolds = 5, seed = 1234)
}
}
\seealso{
{penAFT::penAFT.predict], \link[glmnet:predict.cv.glmnet]{glmnet::coef.cv.glmnet},
}
